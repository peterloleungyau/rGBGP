% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/GBGP.R
\name{steady_state_elitism_GP}
\alias{steady_state_elitism_GP}
\title{A simple steady-state elitism GBGP.}
\usage{
steady_state_elitism_GP(
  init_chrs = NULL,
  init_pop = NULL,
  fitness_evaluator,
  when_to_stop,
  selector = simple_tournament,
  p_crossover = 0.9,
  chr_crossoveror,
  p_mutation = 0.05,
  chr_mutator,
  maximize_fitness = TRUE,
  better_score = NULL,
  reporting_func = NULL
)
}
\arguments{
\item{init_chrs}{Optional, default NULL. If non-NULL, should be an
unnamed list of chromosomes, to be used for the initial
population after fitness evaluation. Note that if this is
non-NULL, then \code{init_pop} is ignored; and the length of this
list will be the population size. If this is NULL, then
\code{init_pop} should be non-NULL.}

\item{init_pop}{Optional, default NULL. If non-NULL, should be an
unnamed list of individuals, where each is an individual as
created by \code{create_individual()}, i.e. a chromosome together
with fitness value. Note that if \code{init_chrs} is non-NULL,
\code{init_pop} is ignored. If \code{init_chrs} is NULL, then
\code{init_pop} should be non-NULL and the length will be the
population size.}

\item{fitness_evaluator}{A function(chr) that gives that evaluates
the chromosome and returns the fitness value. Note that the
fitness value can have arbitrary attributes, which will be
preserved.}

\item{when_to_stop}{Stopping condition function, which should
return TRUE if the evolution should stop after a generation. The
function will get these parameters:\preformatted{pop: the list of current population of individuals, sorted from
the best to worst individuals, according to
\code{maximize_fitness}.

n_gen_ended: the number of generations already done.

cur_best_ind: the current individual with the best fitness
value according to \code{better_score}.

n_gen_of_best_ind: the generation when the current best
individual is first obtained.

start_time: the starting time of the evolution.

n_evals: the number of fitness evaluations performed.
}}

\item{selector}{Optional, default \code{simple_tournament}. This
should be a function(pop, better_score) that when given a list of
population of individuals, and the \code{better_score} function,
should select one individual for crossover or mutation use.}

\item{p_crossover}{Specifies the portion of offsprings created with
crossover in each generation, and should be non-negative. More
specifically, for a population size of \code{n_pop_size},
\code{ceiling(p_crossover * n_pop_size)} offsprings will be
produced from crossover of two selected individuals (using
\code{selector}). Ater new offsprings are created (together with
those created by mutation), the offsprings are unioned with the
parents, and the best (according to \code{better_score})
\code{n_pop_size} individuals are kept for the new
generation. Note that it is allowed to have \code{p_crossover}
greater than 1, and \code{p_crossover + p_mutation} need NOT sum
to 1.}

\item{chr_crossoveror}{A function(chr1, chr2) that should return
the crossovered chromosome. For example, can create a function
that uses \code{chr_crossover_func} by specifying other
parameters.}

\item{p_mutation}{Specifies the portion of offsprings created with
mutation in each generation, and should be non-negative. More
specifically, for a population size of \code{n_pop_size},
\code{ceiling(p_mutation * n_pop_size)} offsprings will be
produced from mutation of one selected individual (using
\code{selector}). Ater new offsprings are created (together with
those created by crossover), the offsprings are unioned with the
parents, and the best (according to \code{better_score})
\code{n_pop_size} individuals are kept for the new
generation. Note that it is allowed to have \code{p_mutation}
greater than 1, and \code{p_crossover + p_mutation} need NOT sum
to 1.}

\item{chr_mutator}{A function(chr) that should return a mutated
chromosome. For example, create a function that uses
\code{chr_mutation_func} by specifying other paramters.}

\item{maximize_fitness}{Optional, default TRUE. If TRUE, to
maximize fitness; otherwise will minimize fitness. Note that the
population in each generation will be sorted using R's built-in
sorting according to \code{maximize_fitness}, so can only compare
numerical value, and may be less general than
\code{better_score}.}

\item{better_score}{Optional, defualt NULL. If NULL, will use
\code{>} if \code{maximize_fitness} is TRUE, and use \code{<}
otherwise. If non-NULL, should be a function(fitness1, fitness2)
that should return TRUE if fitness1 is better than fitness2. Note
that this function is used in selecting individuals, and can
possibly use more information from the fitness (if there are
attributes) to determine the better fitness, but it is
recommended that it be consistent with \code{maximize_fitness}.}

\item{reporting_func}{Optional, default NULL. If non-NULL, it
should be a function that receives the same paramters as the
stopping condition function in \code{when_to_stop} and reports
the progress at the end of a generation. Note that it is entirely
up to this function to determine whether to report progress, and
to what verbosity level.}
}
\value{
Returns a named list with:\preformatted{pop: the list of population of individuals, sorted from the
best to worst individuals, according to
\code{maximize_fitness}.

n_gen_ended: the number of generations already done.

best_ind: the individual with the best fitness value found, as
determined by \code{better_score}.

n_gen_of_best_ind: the generation when the best individual is
first obtained.

start_time: the starting time of the evolution.

end_time: the ending time of the evolution.

n_evals: the number of fitness evaluations performed.
}
}
\description{
A simple steady-state elitism GBGP.
}
\examples{
\dontrun{
# To test the simple GBGP
#
# test on the simple 6-Multiplexor problem, using grammar described in
#  P.A. Whigham, Grammatically-based genetic programming.
#    in "Proceedings of the Workshop on Genetic Programming: From Theory to Real-World Applications,
#    ed. by J.P. Rosca (Tahoe City, California, USA, 1995), pp. 33--41.
# Briefly, the 6-Multiplexor is:
#   Given boolean inputs a0, a1, d0, d1, d2, d3,
#   Use operators (IF X Y Z), (AND X Y), (OR X Y), (NOT X), to output
#     d0 if a0=0, a1=0;
#     d1 if a0=0, a1=1;
#     d2 if a0=1, a1=0;
#     d3 if a0=1, a1=1;

library(rGBGP)

correct_6_multiplexor <- function(a0, a1, d0, d1, d2, d3) {
  ifelse(a0,
         ifelse(a1, d3, d2),
         ifelse(a1, d1, d0))
}

test_sixmultiplexor_rules <- list(
  B = list(
    # Note that we can optionally manually give a unique name to a
    # rule, otherwise a name will be generated.
    rule("&", "B", "B", name = "r_and"),
    rule("|", "B", "B", name = "r_or"),
    rule("!", "B", name = "r_not"),
    rule("ifelse", "B", "B", "B", name = "r_if"),
    # Rules have default actions for constructing the phenotype, but
    # the action can also be explicitly specified.
    rule("T", action = first)
  ),
  T = list(
    rule("a0", action = first_as_symbol),
    rule("a1", action = first_as_symbol),
    rule("d0", action = first_as_symbol),
    rule("d1", action = first_as_symbol),
    rule("d2", action = first_as_symbol),
    rule("d3", action = first_as_symbol)
  )
)

test_sixmultiplexor_G <- grammar(rules = test_sixmultiplexor_rules,
                                 start = "B")

#' Turn the parse-tree into R function, for evaluation.
#'
#' @param chr The evolved chromosome, as a tree of node.
compile_6_multiplexor_chr <- function(chr) {
  f <- function(a0, a1, d0, d1, d2, d3) {}
  environment(f) <- globalenv()
  body(f) <- convert_to_phenotype(chr, test_sixmultiplexor_G)
  f
}

df_6_multiplexor <- expand.grid(
  a0 = c(TRUE, FALSE),
  a1 = c(TRUE, FALSE),
  d0 = c(TRUE, FALSE),
  d1 = c(TRUE, FALSE),
  d2 = c(TRUE, FALSE),
  d3 = c(TRUE, FALSE)
)

df_6_multiplexor_correct <- with(
  df_6_multiplexor,
  correct_6_multiplexor(a0, a1, d0, d1, d2, d3))

#' To evaluate a function for 6-multiplexor
#'
#' @param f The function(a0, a1, d0, d1, d2, d3).
#' @return The number of correct output given all the possible inputs
#'   to the (a0, a1, d0, d1, d2, d3).
eval_6_multiplexor_func <- function(f) {
  pred <- with(df_6_multiplexor,
               f(a0, a1, d0, d1, d2, d3))
  sum(pred == df_6_multiplexor_correct)
}

eval_6_multiplexor_chr <- function(chr) {
  eval_6_multiplexor_func(compile_6_multiplexor_chr(chr))
}

#' To re-generate a node based on its non-terminal.
#' 
chr_6_multiplexor_re_gen <- function(chr_node) {
  generate_chromosome(chr_node$nt, test_sixmultiplexor_G, 5)
}

#' Height bias in selecting nodes
test_height_bias <- get_height_prob_func(subtree_weight = 0.9, root_weight = 0.3)

# test evolution -------------------------------------------------------------

set.seed(123)

run_6_multiplexor_res <- steady_state_elitism_GP(
  init_chrs = generate_init_chrs(n = 100,
                                 G = test_sixmultiplexor_G,
                                 max_height = 6),
  fitness_evaluator = eval_6_multiplexor_chr,
  when_to_stop = either_or(stop_when_max_gen(1000),
                           stop_when_max_fitness(64)),
  p_crossover = 0.8,
  chr_crossover = function(chr1, chr2) {
    # use default values for other parameters
    chr_crossover_func(chr1, chr2,
                       height_prob_func1 = test_height_bias,
                       height_prob_func2 = test_height_bias,
                       max_height = 8)
  },
  p_mutation = 0.2,
  chr_mutator = function(chr) {
    chr_mutation_func(chr, chr_6_multiplexor_re_gen)
  },
  maximize_fitness = TRUE,
  reporting_func = progress_reporter(report_every_n_gen = 1)
)

best_6_multiplexor_found <- run_6_multiplexor_res$best_ind

convert_to_phenotype(best_6_multiplexor_found$chr, test_sixmultiplexor_G)

}
}
